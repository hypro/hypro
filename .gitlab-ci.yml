image: ubuntu:22.04


variables:

  SONAR_SERVER_URL: https://sonarcloud.io
  SONAR_SCANNER_VERSION: 4.6.1.2450  
  # BUILD_WRAPPER_OUT_DIR: bw-output # Directory where build-wrapper output will be placed
  
  SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
  GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
  # note that SONAR_TOKEN is transmitted to the environment through Gitlab CI

get-sonar-binaries:
  # this job download and unpacks the build-wrapper and the sonar-scanner
  # in this example it is done for every build.
  # This can be optimized by caching the files or better, by including them, in the build docker image.
  stage: .pre

  before_script:
    - DEBIAN_FRONTEND=noninteractive apt-get update
    - DEBIAN_FRONTEND=noninteractive apt install -y curl zip unzip
  script:
    # Download sonar-scanner
    - curl -sSLo sonar-scanner.zip "https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-${SONAR_SCANNER_VERSION}-linux.zip"
    - unzip -o sonar-scanner.zip 
    - mv sonar-scanner-${SONAR_SCANNER_VERSION}-linux sonar-scanner
    # Download build-wrapper
    - curl -sSLo build-wrapper.zip "${SONAR_SERVER_URL}/static/cpp/build-wrapper-linux-x86.zip" 
    - unzip -o build-wrapper.zip
    - mv build-wrapper-linux-x86 build-wrapper
  cache:
    policy: push
    key: "${CI_COMMIT_SHORT_SHA}"
    paths:
      - build-wrapper/ # to share the build-wrapper between jobs
      - sonar-scanner/ # to share the sonar-scanner between jobs

  # artifacts:
  #   paths:
  #     - .
  #   exclude:
  #     - .git
  #     - .git/**/*
  #     - build/**/*.o


build:
  stage: build
  # install the necessary build tools when needed
  before_script:
    - DEBIAN_FRONTEND=noninteractive apt-get update
    - DEBIAN_FRONTEND=noninteractive apt install -y gcc g++ cmake make curl git flex bison libeigen3-dev uuid-dev libboost-system-dev libboost-program-options-dev libboost-test-dev libboost-timer-dev libboost-chrono-dev libboost-serialization-dev libbliss-dev gcovr zip unzip
    - git clone  --depth 1 --branch 22.12 https://github.com/ths-rwth/carl carl && cd carl
    - mkdir build && cd build && cmake .. -DUSE_LIBPOLY=OFF
    - make -j`nproc` carl-common
    - make -j`nproc` carl-arith
    - make -j`nproc` carl-logging
    - make -j`nproc` carl-formula
    - cd ../..
  script:
    # prepare the build tree
    - mkdir build && cd build && cmake .. -DHYPRO_CICD=ON && make -j`nproc` && cd ..
    # - cmake -S . -B build
    # run the build inside the build wrapper
    - build-wrapper/build-wrapper-linux-x86-64 --out-dir "${BUILD_WRAPPER_OUT_DIR}" cmake --build build/ --config Release 
  artifacts:
    paths:
      - build/sonar_scanner_example
  cache:
    policy: pull-push
    key: "${CI_COMMIT_SHORT_SHA}"
    paths:
      - build-wrapper/
      - sonar-scanner/
      - "${BUILD_WRAPPER_OUT_DIR}/"
      - build/
      

sonarqube-check:
  stage: .post
  cache:
    policy: pull
    key: "${CI_COMMIT_SHORT_SHA}"
    paths:
      - sonar-scanner/
      - "${BUILD_WRAPPER_OUT_DIR}"
      - build/
  script:
    - sonar-scanner/bin/sonar-scanner -X --define sonar.host.url="${SONAR_SERVER_URL}" --define sonar.cfamily.build-wrapper-output="${BUILD_WRAPPER_OUT_DIR}" -Dsonar.token="${SONAR_TOKEN}"
  # only:
  #   - merge_requests
  #   - main
  #   - develop







# build:
#   stage: build
#   # instead of calling g++ directly you can also use some build toolkit like make
#   # install the necessary build tools when needed
#   before_script:
#     - DEBIAN_FRONTEND=noninteractive apt-get update
#     - DEBIAN_FRONTEND=noninteractive apt install -y gcc g++ cmake make git flex bison libeigen3-dev uuid-dev libboost-system-dev libboost-program-options-dev libboost-test-dev libboost-timer-dev libboost-chrono-dev libboost-serialization-dev libbliss-dev gcovr
#     - git clone  --depth 1 --branch 22.12 https://github.com/ths-rwth/carl carl && cd carl
#     - mkdir build && cd build && cmake .. -DUSE_LIBPOLY=OFF
#     - make -j`nproc` carl-common
#     - make -j`nproc` carl-arith
#     - make -j`nproc` carl-logging
#     - make -j`nproc` carl-formula
#     - cd ../..
#   script:
#     - mkdir build && cd build && cmake .. -DHYPRO_CICD=ON && make -j`nproc`
#   cache:
#     key: $CI_COMMIT_REF_SLUG
#     paths:
#       - carl/
#   artifacts:
#     paths:
#       - .
#     exclude:
#       - .git
#       - .git/**/*
#       - build/**/*.o

# sonarcloud:
#   stage: build
#   image:
#     name: sonarsource/sonar-scanner-cli:latest
#     entrypoint: [""]
#   cache:
#     key: "${CI_JOB_NAME}"
#     paths:
#       - .sonar/cache
#   script:
#     - sonar-scanner
#   # rules:
#   #     - if: $CI_COMMIT_REF_NAME == 'main' || $CI_PIPELINE_SOURCE == 'merge_request_event'


#       # run tests using the binary built before
# test:
#   stage: test
#   before_script:
#     - DEBIAN_FRONTEND=noninteractive apt-get update
#     - DEBIAN_FRONTEND=noninteractive apt install -y gcc g++ cmake make git flex bison libeigen3-dev uuid-dev libboost-system-dev libboost-program-options-dev libboost-test-dev libboost-timer-dev libboost-chrono-dev libboost-serialization-dev libbliss-dev gcovr
#   script:
#     - ctest --test-dir build --output-junit junit.xml
#   artifacts:
#     reports:
#       junit: build/junit.xml
  
